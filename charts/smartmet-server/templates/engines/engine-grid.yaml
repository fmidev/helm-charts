apiVersion: v1
kind: ConfigMap
metadata:
  name: smartmet-engine-grid-config
data: 
  config: |
    ## GENERATED BY HELM ##
    smartmet :
    {
    library :
    {

    grid-files :
    {
      configFile = "/config/libraries/grid-files/grid-files.conf"
      memoryMapper :
      {
        enabled = {{ default false .Values.config.engines.grid.memoryMapper.enabled}}
        premapEnabled = true;
      }
        
      cache :
      {
        numOfGrids         = 50000
        maxSizeInMegaBytes = 30000
      }
      
    } # grid-files

    } # library


    engine :
    {
    grid :
    {
    enabled = {{ not .Values.config.engines.grid.disabled }}
    content-server :
    {
      content-source : 
      {
        # Content source type (redis/corba/http/file)

        type = "redis"

        redis :
        {
          address           = "{{ .Values.config.redis.address }}"
          port              = {{ .Values.config.redis.port }}
          tablePrefix       = "{{ .Values.config.redis.tablePrefix }}"
          lockEnable        = false;
          reloadRequired    = true;

        # Grid files can be released from the memory if they are not accessed in a given time (= age in seconds). 
        # This feature is useful especially with archive installations that might contains millions of 
        # grids, which are rarely accessed.
        
        clean-up :
        {
          age = 360000
          checkInterval = 3600  
        }    
      }

        corba :
        {
          ior          = ""
        }

        http :
        {
          url          = ""
        }
        
        file :
        {
          contentDir          = "/tmp/"
          
        
          # Size of the event list. If there are no local cache then this size should be 0.
          # Otherwise it should be quite big (1000000 - 5000000) 
        
          eventListMaxSize = 0                   
        }      
        
      }

      processing-log :
      {
        enabled      = {{ default false .Values.config.engines.grid.logging.processing.enabled }}
        file         = "{{ if eq .Values.logging.target "stdout" -}} /dev/stdout {{- else -}} {{ .Values.logging.directory }}/grid-engine-processing-log {{- end }}"
        maxSize      = 100000000
        truncateSize = 20000000
      }

      debug-log :
      {
        enabled      = {{ default false .Values.config.engines.grid.logging.debug.enabled }}
        file         = "{{ if eq .Values.logging.target "stdout" -}} /dev/stdout {{- else -}} {{ .Values.logging.directory }}/grid-engine-debug-log {{- end }}"
        maxSize      = 100000000
        truncateSize = 20000000
      }

      cache :
      {
        enabled	= true

        # Should the get requests be forwarded to the original content source when the cache update is in progress 

        requestForwardEnabled = false   
        
        # Fast searches require that content information is sorted. However, it is usually a little bit difficult to update
        # this kind of structure in real-time so that it does not slow down search requests, especially when there are several      
        # updates and hundreds of parallel requests going on at the same time. In this case we should use content swapping.  
        # The idea is that we have two different structures: the first one is used for continious updates and the second one 
        # is used for searches. So the first structure is always up to date and we do not use it for searches. However, we 
        # swap this structure to the search structure time to time (=> contentUpdateInterval). This kind of swapping is 
        # very fast operation and does not cause any significant breaks for searches.
        
        # Notice that the content swapping increases the memory consumtion a little bit. You do not need to use it
        # if your content is not continuously updated.  
              
        contentSwapEnabled = true
        
        contentUpdateInterval = 180       

    }
    }



    # The data server is responsible for fetching actual data from the grid files. It is possible
    # to use a local or a remote data server. The data server uses also a lot of memory and maps
    # grid files into virtual memory. That's why it would be smarter to use shared data servers
    # when possible. On the other hand, the remote data server is usually always up and running
    # which means that it can be used immediately. If the data server is local then it
    # takes some time to start the system and make sure that all grid files are available.
    # If the remote data server is disabled then the local data server is used in the engine.

    data-server :
    {
      ######  The remote data server. Notice that the remote data server has its own configuration file.

      remote  = false
      caching = false
      ior     = ""


      ######  The local data server. These settings are valid when the "remote" attribute is "false".

      # Location of grid files.

      grid-storage :
      {
        directory = "$(GRID_FILE_STORAGE_DIR)"
        memoryMapCheckEnabled = false
        preloadEnabled = false
        preloadMemoryLock = false
        preloadFile = "%(DIR)/grid-engine/preload.csv" 
        
        # Grid files can be released from the memory if they are not accessed in a given time (= age in seconds). 
        # This feature is useful especially with archive installations that might contains millions of 
        # grids, which are rarely accessed.
        
        clean-up :
        {
          age = 3600
          checkInterval = 300  
        }        
      }


      # The data server can generate "virtual grid files" that are based on
      # existing grid files. The definition file is used in order to define
      # requirements (= required parameters) and rules (= LUA function) for
      # new virtual files.

      # TODO this crashes the server if file is missing even if enabled=false

      virtualFiles :
      {
        enabled = false
        definitionFile = "/config/engines/grid-engine/vff_convert.csv"
      }

      # LUA files are usually needed for generating content for the virtual
      # files. In practice, each virtual file definition contains the name
      # of the LUA function that needs to be called when the data of
      # the current virtual file is requested.

      luaFiles =
      [
        "/config/engines/grid-engine/vff_convert.lua"
      ];

      processing-log :
      {
        enabled      = {{ default false .Values.config.engines.grid.logging.processing.enabled }}
        file         = "{{ if eq .Values.logging.target "stdout" -}} /dev/stdout {{- else -}} {{ .Values.logging.directory }}/grid-engine-data-server-processing-log {{- end }}"
        maxSize      = 100000000
        truncateSize = 20000000
      }

      debug-log :
      {
        enabled      = {{ default false .Values.config.engines.grid.logging.debug.enabled }}
        file         = "{{ if eq .Values.logging.target "stdout" -}} /dev/stdout {{- else -}} {{ .Values.logging.directory }}/grid-engine-data-server-debug-log {{- end }}"
        maxSize      = 100000000
        truncateSize = 20000000
      }
    }


    # The query server is responsible for making data queries to the data server according
    # to the content information that it gets from the content server. Also the query server
    # can be local or remote. Sometimes it is smarter to locate the query server closer to
    # the content server and the data server, because there might be a lot traffic between them.
    # If the remote query server is disabled then the local query server is used in the engine.

    query-server :
    {
      remote  = false
      ior     = ""

      
      # If you want to search data from a certain producer then this producer must be listed in 
      # this file. On the other hand, this file defines the search order of the producers and geometries 
      # in the case of that the producer or the geometry is not defined.  

      producerFile = "/config/engines/grid-engine/producers.csv"
        
      producerStatusFile = "%(DIR)/grid-engine/stat_newbase_producers.cfg"  

      # The producer mapping files are used for mapping newbase producers and parameters to the correct
      # grib producers, gemetries and level types. 

      producerMappingFiles = 
      [
        # #"%(DIR)/grid-engine/pm_ecmwf_eurooppa_mallipinta.cfg",
        # #"%(DIR)/grid-engine/pm_ecmwf_eurooppa_painepinta.cfg",
        # #"%(DIR)/grid-engine/pm_ecmwf_eurooppa_pinta.cfg",
        # #"%(DIR)/grid-engine/pm_ecmwf_europe_probability.cfg",
        # #"%(DIR)/grid-engine/pm_ecmwf_maailma_mallipinta.cfg",
        # #"%(DIR)/grid-engine/pm_ecmwf_maailma_painepinta.cfg",
        # "%(DIR)/grid-engine/pm_ecmwf_maailma_pinta.cfg",
        # #"%(DIR)/grid-engine/pm_gfs.cfg",
        # #"%(DIR)/grid-engine/pm_harmonie_scandinavia_surface.cfg",
        # "%(DIR)/grid-engine/pm_pal_skandinavia.cfg",
        # "%(DIR)/grid-engine/pm_mos_eurooppa_pinta.cfg",
        # "%(DIR)/grid-engine/pm_smartmet_nowcast_scandinavia_surface.cfg"    
      ];

      queryCache :
      {
        # A query object is removed from the cache if it accessed in this time (seconds). 
        
        enabled = false
        maxAge = 3600
      }

      
      contentCache:
      {  
        maxRecordsPerThread = 100000
        clearInterval = 36000
      }
      
      contentSearchCache:
      {  
        maxRecordsPerThread = 100000
        clearInterval = 36000
      }

      # If the gridEngine notices that there are not valid mappings available for all
      # parameters found from the contentServer, then it automatically adds these unmapped
      # parameters to the following files. The queryServer needs these mappings in order to
      # find the current parameters. You can move these automatically generated mappings into
      # a more permanent mapping file (mappings_fmi_auto.csv => mappings_fmi.csv). On the other
      # hand, when the permanent mapping files are empty then you can get your basic mapping
      # settings from these automatically generated files (i.e. when you are first time
      # configuring your system).


      # 1 = FMI_ID, 2 = FMI_NAME, 3 = GRIB_ID, 4 = NEWBASE_ID, 5 = NEWBASE_NAME, 6 = CDM_ID, 7 = CDM_NAME

      mappingTargetKeyType = 2

      mappingUpdateFile :
      {
        fmi     = "/var/smartmet/grid/mapping_fmi_auto.csv"
        newbase = "/var/smartmet/grid/mapping_newbase_auto.csv"
        netCdf  = "/var/smartmet/grid/mapping_netCdf_auto.csv"
      }

      luaFiles =
      [
        # "%(DIR)/grid-engine/function_basic.lua",
        # "%(DIR)/grid-engine/function_interpolation.lua",
        # "%(DIR)/grid-engine/function_conversion.lua",
        # "%(DIR)/grid-engine/function_newbase.lua",
        # "%(DIR)/grid-engine/function_demo.lua",
        # "%(DIR)/grid-engine/function_railrule5.lua"
      ];

      mappingFiles =
      [
        "/config/libraries/mappings/mapping_fmi.csv",
        "/var/smartmet/grid/mapping_fmi_auto.csv",
        # "%(DIR)/grid-engine/mapping_newbase.csv",
        # "/var/smartmet/grid/mapping_newbase_auto.csv",
        # "%(DIR)/grid-engine/mapping_virtual.csv",
        # "%(DIR)/grid-engine/mapping_netCdf.csv",
        # "/var/smartmet/grid/mapping_netCdf_auto.csv",
      ];

      aliasFiles =
      [
        # "%(DIR)/grid-engine/alias_demo.cfg",
        # "%(DIR)/grid-engine/alias_newbase_extension.cfg"
      ];

      processing-log :
      {
        enabled      = {{ default false .Values.config.engines.grid.logging.processing.enabled }}
        file         = "{{ if eq .Values.logging.target "stdout" -}} /dev/stdout {{- else -}} {{ .Values.logging.directory }}/grid-engine-query-server-processing-log {{- end }}"
        maxSize      = 100000000
        truncateSize = 20000000
      }

      debug-log :
      {
        enabled      = {{ default false .Values.config.engines.grid.logging.debug.enabled }}
        file         = "{{ if eq .Values.logging.target "stdout" -}} /dev/stdout {{- else -}} {{ .Values.logging.directory }}/grid-engine-query-server-debug-log {{- end }}"
        maxSize      = 100000000
        truncateSize = 20000000
      }
    }

    # smartmet-plugin-grid-admin can browse information in the grid engine. 

    browser :
    {
      enabled  = true
      
      # This field is used for defining permissions for the browsing. Permissions are
      # expressed with bits (0 = disabled, 1 = enabled)
      # 
      #   bit 0 : Content modification
      #   bit 1 : Log modification
      
      flags    = 1
    }

    }
    }
    }
